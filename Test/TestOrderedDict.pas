unit TestOrderedDict;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, System.Generics.Collections, uOrderedDict, System.SysUtils;

type
  // Test methods for class TOrderedDict

  TestTOrderedDict = class(TTestCase)
  strict private
    FOrderedDict: TOrderedDict<string, TObject>;
    procedure FillDictWithCount(const ADict: TOrderedDict<string, TObject>; const ACount: Integer);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCountNull;
    procedure TestCountSix;
    procedure TestAdd;
    procedure TestInsertAtNull;
    procedure TestInsertAtMiddle;
    procedure TestInsertAtStart;
    procedure TestInsertAtEnd;
    procedure TestContainsKey;
    procedure TestKeyByIndex;
    procedure TestNotContainsKey;
    procedure TestContainsValue;
    procedure TestNotContainsValue;
    procedure TestIndexOf;
    procedure TestRemove;
    procedure TestClear;
    procedure TestRemoveAllValues;
    procedure TestDelete;
    procedure TestMove;
  end;

implementation

procedure TestTOrderedDict.FillDictWithCount(const ADict: TOrderedDict<string, TObject>; const ACount: Integer);
var
  i: Integer;
  AKey: string;
  AValue: TObject;
begin
  for i := 0 to ACount - 1 do
  begin
    AKey := 'Key' + IntToStr(i);
    AValue := TObject.Create;
    ADict.Add(AKey, AValue);
  end;
end;

procedure TestTOrderedDict.SetUp;
begin
  FOrderedDict := TOrderedDict<string, TObject>.Create;
end;

procedure TestTOrderedDict.TearDown;
begin
  FOrderedDict.Free;
  FOrderedDict := nil;
end;

procedure TestTOrderedDict.TestClear;
begin
  FillDictWithCount(FOrderedDict, 10);
  FOrderedDict.Clear;

  Check(
    FOrderedDict.Count = 0
  );
end;

procedure TestTOrderedDict.TestContainsKey;
begin
  FillDictWithCount(FOrderedDict, 10);

  Check(
    FOrderedDict.ContainsKey('Key0') and
    FOrderedDict.ContainsKey('Key5') and
    FOrderedDict.ContainsKey('Key9')
  );
end;

procedure TestTOrderedDict.TestContainsValue;
var
  vObj: TObject;
begin
  FillDictWithCount(FOrderedDict, 10);

  vObj := TObject.Create;
  FOrderedDict.Add('Key10', vObj);

  Check(
    FOrderedDict.ContainsValue(vObj)
  );
end;

procedure TestTOrderedDict.TestCountNull;
var
  ReturnValue: Integer;
begin
  ReturnValue := FOrderedDict.Count;
  // TODO: Validate method results
  Check(ReturnValue = 0);
end;

procedure TestTOrderedDict.TestCountSix;
var
  ReturnValue: Integer;
begin
  FillDictWithCount(FOrderedDict, 6);
  ReturnValue := FOrderedDict.Count;
  // TODO: Validate method results
  Check(ReturnValue = 6);
end;

procedure TestTOrderedDict.TestAdd;
var
  AValue: TObject;
  AKey: string;
begin
  AValue := TObject.Create;
  AKey := 'TestKey';
  // TODO: Setup method call parameters
  FOrderedDict.Add(AKey, AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 1) and
    (FOrderedDict[0] = AValue) and
    (FOrderedDict[AKey] = AValue)
  );
end;

procedure TestTOrderedDict.TestIndexOf;
begin
  FillDictWithCount(FOrderedDict, 10);

  Check(
    (FOrderedDict.IndexOf('Key0') = 0) and
    (FOrderedDict.IndexOf('Key5') = 5) and
    (FOrderedDict.IndexOf('Key9') = 9)
  );
end;

procedure TestTOrderedDict.TestInsertAtEnd;
var
  AValue: TObject;
  AKey: string;
  AIndex: Integer;
begin
  FillDictWithCount(FOrderedDict, 10);
  AValue := TObject.Create;
  AKey := 'TestKey';
  AIndex := 10;

  // TODO: Setup method call parameters
  FOrderedDict.Insert(AIndex, AKey, AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 11) and
    (FOrderedDict[AIndex] = AValue) and
    (FOrderedDict[AKey] = AValue) and
    (FOrderedDict.ContainsKey('Key8')) and
    (FOrderedDict.ContainsKey('Key9')) and
    (FOrderedDict.ContainsKey(AKey))
  );
end;

procedure TestTOrderedDict.TestInsertAtMiddle;
var
  AValue: TObject;
  AKey: string;
  AIndex: Integer;
begin
  FillDictWithCount(FOrderedDict, 10);
  AValue := TObject.Create;
  AKey := 'TestKey';
  AIndex := 5;

  // TODO: Setup method call parameters
  FOrderedDict.Insert(AIndex, AKey, AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 11) and
    (FOrderedDict[AIndex] = AValue) and
    (FOrderedDict[AKey] = AValue) and
    (FOrderedDict.ContainsKey('Key4')) and
    (FOrderedDict.ContainsKey('Key5')) and
    (FOrderedDict.ContainsKey(AKey))
  );
end;

procedure TestTOrderedDict.TestInsertAtNull;
var
  AValue: TObject;
  AKey: string;
  AIndex: Integer;
begin
  AValue := TObject.Create;
  AKey := 'TestKey';
  AIndex := 0;
  // TODO: Setup method call parameters
  FOrderedDict.Insert(AIndex, AKey, AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 1) and
    (FOrderedDict[0] = AValue) and
    (FOrderedDict[AKey] = AValue)
  );
end;

procedure TestTOrderedDict.TestInsertAtStart;
var
  AValue: TObject;
  AKey: string;
  AIndex: Integer;
begin
  FillDictWithCount(FOrderedDict, 10);
  AValue := TObject.Create;
  AKey := 'TestKey';
  AIndex := 0;

  // TODO: Setup method call parameters
  FOrderedDict.Insert(AIndex, AKey, AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 11) and
    (FOrderedDict[AIndex] = AValue) and
    (FOrderedDict[AKey] = AValue) and
    (FOrderedDict.ContainsKey('Key0')) and
    (FOrderedDict.ContainsKey('Key1')) and
    (FOrderedDict.ContainsKey(AKey))
  );
end;

procedure TestTOrderedDict.TestKeyByIndex;
begin
  FillDictWithCount(FOrderedDict, 10);

  Check(
    (FOrderedDict.KeyByIndex[0] = 'Key0') and
    (FOrderedDict.KeyByIndex[9] = 'Key9') and
    (FOrderedDict.KeyByIndex[5] = 'Key5')
  );
end;

procedure TestTOrderedDict.TestMove;
var
  vZero, vOne, vNine: TOBject;
begin
  FillDictWithCount(FOrderedDict, 10);

  vZero := FOrderedDict[0];
  vOne := FOrderedDict[1];
  vNine := FOrderedDict[9];

  FOrderedDict.Move(0, 9);

  Check(
    (vZero = FOrderedDict[9]) and
    (vNine = FOrderedDict[8]) and
    (vOne = FOrderedDict[0])
  );
end;

procedure TestTOrderedDict.TestNotContainsKey;
begin
  FillDictWithCount(FOrderedDict, 10);

  CheckFalse(
    FOrderedDict.ContainsKey('Key11') and
    FOrderedDict.ContainsKey('Key12') and
    FOrderedDict.ContainsKey('key01')
  );
end;

procedure TestTOrderedDict.TestNotContainsValue;
var
  vObj: TObject;
begin
  FillDictWithCount(FOrderedDict, 10);

  vObj := TObject.Create;

  CheckFalse(
    FOrderedDict.ContainsValue(vObj)
  );
end;

procedure TestTOrderedDict.TestRemove;
var
  vKey: string;
begin
  FillDictWithCount(FOrderedDict, 5);
  // TODO: Setup method call parameters
  vKey := 'Key2';
  FOrderedDict.Remove(vKey);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 4) and
    (FOrderedDict['Key0'] <> nil) and
    (FOrderedDict['Key1'] <> nil) and
    (FOrderedDict['Key3'] <> nil) and
    (FOrderedDict['Key4'] <> nil)
  );
end;

procedure TestTOrderedDict.TestRemoveAllValues;
var
  AValue: TObject;
begin
  // TODO: Setup method call parameters
  FillDictWithCount(FOrderedDict, 5);
  AValue := FOrderedDict[2];
  FOrderedDict.Add('Key5', AValue);
  FOrderedDict.RemoveAllValues(AValue);
  // TODO: Validate method results
  Check(
    (FOrderedDict.Count = 4) and
    (FOrderedDict['Key0'] <> nil) and
    (FOrderedDict['Key1'] <> nil) and
    (FOrderedDict['Key3'] <> nil) and
    (FOrderedDict['Key4'] <> nil)
  );
end;

procedure TestTOrderedDict.TestDelete;
var
  AIndex: Integer;
begin
  // TODO: Setup method call parameters
  FillDictWithCount(FOrderedDict, 5);
  AIndex := 1;
  FOrderedDict.Delete(AIndex);
  // TODO: Validate method results
    Check(
    (FOrderedDict.Count = 4) and
    (FOrderedDict['Key0'] <> nil) and
    (FOrderedDict['Key2'] <> nil) and
    (FOrderedDict['Key3'] <> nil) and
    (FOrderedDict['Key4'] <> nil)
  );
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTOrderedDict.Suite);
end.

